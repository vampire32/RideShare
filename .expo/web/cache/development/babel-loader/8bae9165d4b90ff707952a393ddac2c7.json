{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport AnimatedImplementation from \"../../Animated/AnimatedImplementation\";\nimport AnimatedAddition from \"../../Animated/nodes/AnimatedAddition\";\nimport AnimatedDiffClamp from \"../../Animated/nodes/AnimatedDiffClamp\";\nimport AnimatedNode from \"../../Animated/nodes/AnimatedNode\";\nimport * as React from 'react';\nimport StyleSheet from \"../../StyleSheet/StyleSheet\";\nimport View from \"../View/View\";\nimport Platform from \"../../Utilities/Platform\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\nvar ScrollViewStickyHeader = function (_React$Component) {\n  _inherits(ScrollViewStickyHeader, _React$Component);\n  var _super = _createSuper(ScrollViewStickyHeader);\n  function ScrollViewStickyHeader() {\n    var _this;\n    _classCallCheck(this, ScrollViewStickyHeader);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.state = {\n      measured: false,\n      layoutY: 0,\n      layoutHeight: 0,\n      nextHeaderLayoutY: _this.props.nextHeaderLayoutY,\n      translateY: null\n    };\n    _this._translateY = null;\n    _this._shouldRecreateTranslateY = true;\n    _this._haveReceivedInitialZeroTranslateY = true;\n    _this._debounceTimeout = Platform.OS === 'android' ? 15 : 64;\n    _this.setNextHeaderY = function (y) {\n      _this._shouldRecreateTranslateY = true;\n      _this.setState({\n        nextHeaderLayoutY: y\n      });\n    };\n    _this._onLayout = function (event) {\n      var layoutY = event.nativeEvent.layout.y;\n      var layoutHeight = event.nativeEvent.layout.height;\n      var measured = true;\n      if (layoutY !== _this.state.layoutY || layoutHeight !== _this.state.layoutHeight || measured !== _this.state.measured) {\n        _this._shouldRecreateTranslateY = true;\n      }\n      _this.setState({\n        measured: measured,\n        layoutY: layoutY,\n        layoutHeight: layoutHeight\n      });\n      _this.props.onLayout(event);\n      var child = React.Children.only(_this.props.children);\n      if (child.props.onLayout) {\n        child.props.onLayout(event);\n      }\n    };\n    _this._setComponentRef = function (ref) {\n      _this._ref = ref;\n    };\n    return _this;\n  }\n  _createClass(ScrollViewStickyHeader, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._translateY != null && this._animatedValueListenerId != null) {\n        this._translateY.removeListener(this._animatedValueListenerId);\n      }\n      if (this._timer) {\n        clearTimeout(this._timer);\n      }\n    }\n  }, {\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      if (nextProps.scrollViewHeight !== this.props.scrollViewHeight || nextProps.scrollAnimatedValue !== this.props.scrollAnimatedValue || nextProps.inverted !== this.props.inverted) {\n        this._shouldRecreateTranslateY = true;\n      }\n    }\n  }, {\n    key: \"updateTranslateListener\",\n    value: function updateTranslateListener(translateY, isFabric, offset) {\n      var _this2 = this;\n      if (this._translateY != null && this._animatedValueListenerId != null) {\n        this._translateY.removeListener(this._animatedValueListenerId);\n      }\n      offset ? this._translateY = new AnimatedAddition(translateY, offset) : this._translateY = translateY;\n      this._shouldRecreateTranslateY = false;\n      if (!isFabric) {\n        return;\n      }\n      if (!this._animatedValueListener) {\n        this._animatedValueListener = function (_ref) {\n          var value = _ref.value;\n          if (value === 0 && !_this2._haveReceivedInitialZeroTranslateY) {\n            _this2._haveReceivedInitialZeroTranslateY = true;\n            return;\n          }\n          if (_this2._timer) {\n            clearTimeout(_this2._timer);\n          }\n          _this2._timer = setTimeout(function () {\n            if (value !== _this2.state.translateY) {\n              _this2.setState({\n                translateY: value\n              });\n            }\n          }, _this2._debounceTimeout);\n        };\n      }\n      if (this.state.translateY !== 0 && this.state.translateY != null) {\n        this._haveReceivedInitialZeroTranslateY = false;\n      }\n      this._animatedValueListenerId = translateY.addListener(this._animatedValueListener);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$_ref$_internalI, _this$_ref$_internalI2;\n      var isFabric = !!(\n      this._ref && (_this$_ref$_internalI = this._ref['_internalInstanceHandle']) != null && (_this$_ref$_internalI2 = _this$_ref$_internalI.stateNode) != null && _this$_ref$_internalI2.canonical);\n      if (this._shouldRecreateTranslateY) {\n        var _this$props = this.props,\n          inverted = _this$props.inverted,\n          scrollViewHeight = _this$props.scrollViewHeight;\n        var _this$state = this.state,\n          measured = _this$state.measured,\n          layoutHeight = _this$state.layoutHeight,\n          layoutY = _this$state.layoutY,\n          nextHeaderLayoutY = _this$state.nextHeaderLayoutY;\n        var inputRange = [-1, 0];\n        var outputRange = [0, 0];\n        if (measured) {\n          if (inverted) {\n            if (scrollViewHeight != null) {\n              var stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n              if (stickStartPoint > 0) {\n                inputRange.push(stickStartPoint);\n                outputRange.push(0);\n                inputRange.push(stickStartPoint + 1);\n                outputRange.push(1);\n                var collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n                if (collisionPoint > stickStartPoint) {\n                  inputRange.push(collisionPoint, collisionPoint + 1);\n                  outputRange.push(collisionPoint - stickStartPoint, collisionPoint - stickStartPoint);\n                }\n              }\n            }\n          } else {\n            inputRange.push(layoutY);\n            outputRange.push(0);\n            var _collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n            if (_collisionPoint >= layoutY) {\n              inputRange.push(_collisionPoint, _collisionPoint + 1);\n              outputRange.push(_collisionPoint - layoutY, _collisionPoint - layoutY);\n            } else {\n              inputRange.push(layoutY + 1);\n              outputRange.push(1);\n            }\n          }\n        }\n        this.updateTranslateListener(this.props.scrollAnimatedValue.interpolate({\n          inputRange: inputRange,\n          outputRange: outputRange\n        }), isFabric, this.props.hiddenOnScroll ? new AnimatedDiffClamp(this.props.scrollAnimatedValue.interpolate({\n          extrapolateLeft: 'clamp',\n          inputRange: [layoutY, layoutY + 1],\n          outputRange: [0, 1]\n        }).interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, -1]\n        }), -this.state.layoutHeight, 0) : null);\n      }\n      var child = React.Children.only(this.props.children);\n\n      var passthroughAnimatedPropExplicitValues = isFabric && this.state.translateY != null ? {\n        style: {\n          transform: [{\n            translateY: this.state.translateY\n          }]\n        }\n      } : null;\n      return _jsx(AnimatedView, {\n        collapsable: false,\n        nativeID: this.props.nativeID,\n        onLayout: this._onLayout,\n        ref: this._setComponentRef,\n        style: [child.props.style, styles.header, {\n          transform: [{\n            translateY: this._translateY\n          }]\n        }],\n        passthroughAnimatedPropExplicitValues: passthroughAnimatedPropExplicitValues,\n        children: React.cloneElement(child, {\n          style: styles.fill,\n          onLayout: undefined\n        })\n      });\n    }\n  }]);\n  return ScrollViewStickyHeader;\n}(React.Component);\nvar styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n    position: 'relative'\n  },\n  fill: {\n    flex: 1\n  }\n});\nmodule.exports = ScrollViewStickyHeader;","map":{"version":3,"names":["AnimatedImplementation","AnimatedAddition","AnimatedDiffClamp","AnimatedNode","React","StyleSheet","View","Platform","AnimatedView","createAnimatedComponent","ScrollViewStickyHeader","state","measured","layoutY","layoutHeight","nextHeaderLayoutY","props","translateY","_translateY","_shouldRecreateTranslateY","_haveReceivedInitialZeroTranslateY","_debounceTimeout","OS","setNextHeaderY","y","setState","_onLayout","event","nativeEvent","layout","height","onLayout","child","Children","only","children","_setComponentRef","ref","_ref","_animatedValueListenerId","removeListener","_timer","clearTimeout","nextProps","scrollViewHeight","scrollAnimatedValue","inverted","isFabric","offset","_animatedValueListener","value","setTimeout","addListener","stateNode","canonical","inputRange","outputRange","stickStartPoint","push","collisionPoint","updateTranslateListener","interpolate","hiddenOnScroll","extrapolateLeft","passthroughAnimatedPropExplicitValues","style","transform","nativeID","styles","header","cloneElement","fill","undefined","Component","create","zIndex","position","flex","module","exports"],"sources":["D:/React/TaxiApp/cabApp/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport AnimatedImplementation from '../../Animated/AnimatedImplementation';\nimport AnimatedAddition from '../../Animated/nodes/AnimatedAddition';\nimport AnimatedDiffClamp from '../../Animated/nodes/AnimatedDiffClamp';\nimport AnimatedNode from '../../Animated/nodes/AnimatedNode';\n\nimport * as React from 'react';\nimport StyleSheet from '../../StyleSheet/StyleSheet';\nimport View from '../View/View';\nimport Platform from '../../Utilities/Platform';\n\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\n\nconst AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\nexport type Props = $ReadOnly<{\n  children?: React.Element<any>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: AnimatedImplementation.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n  nativeID?: ?string,\n  hiddenOnScroll?: ?boolean,\n}>;\n\ntype State = {\n  measured: boolean,\n  layoutY: number,\n  layoutHeight: number,\n  nextHeaderLayoutY: ?number,\n  translateY: ?number,\n  ...\n};\n\nclass ScrollViewStickyHeader extends React.Component<Props, State> {\n  state: State = {\n    measured: false,\n    layoutY: 0,\n    layoutHeight: 0,\n    nextHeaderLayoutY: this.props.nextHeaderLayoutY,\n    translateY: null,\n  };\n\n  _translateY: ?AnimatedNode = null;\n  _shouldRecreateTranslateY: boolean = true;\n  _haveReceivedInitialZeroTranslateY: boolean = true;\n  _ref: any; // TODO T53738161: flow type this, and the whole file\n\n  // Fabric-only:\n  _timer: ?TimeoutID;\n  _animatedValueListenerId: string;\n  _animatedValueListener: (valueObject: $ReadOnly<{|value: number|}>) => void;\n  _debounceTimeout: number = Platform.OS === 'android' ? 15 : 64;\n\n  setNextHeaderY: (y: number) => void = (y: number): void => {\n    this._shouldRecreateTranslateY = true;\n    this.setState({nextHeaderLayoutY: y});\n  };\n\n  componentWillUnmount() {\n    if (this._translateY != null && this._animatedValueListenerId != null) {\n      this._translateY.removeListener(this._animatedValueListenerId);\n    }\n    if (this._timer) {\n      clearTimeout(this._timer);\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps: Props) {\n    if (\n      nextProps.scrollViewHeight !== this.props.scrollViewHeight ||\n      nextProps.scrollAnimatedValue !== this.props.scrollAnimatedValue ||\n      nextProps.inverted !== this.props.inverted\n    ) {\n      this._shouldRecreateTranslateY = true;\n    }\n  }\n\n  updateTranslateListener(\n    translateY: AnimatedImplementation.Interpolation,\n    isFabric: boolean,\n    offset: AnimatedDiffClamp | null,\n  ) {\n    if (this._translateY != null && this._animatedValueListenerId != null) {\n      this._translateY.removeListener(this._animatedValueListenerId);\n    }\n    offset\n      ? (this._translateY = new AnimatedAddition(translateY, offset))\n      : (this._translateY = translateY);\n\n    this._shouldRecreateTranslateY = false;\n\n    if (!isFabric) {\n      return;\n    }\n\n    if (!this._animatedValueListener) {\n      // This is called whenever the (Interpolated) Animated Value\n      // updates, which is several times per frame during scrolling.\n      // To ensure that the Fabric ShadowTree has the most recent\n      // translate style of this node, we debounce the value and then\n      // pass it through to the underlying node during render.\n      // This is:\n      // 1. Only an issue in Fabric.\n      // 2. Worse in Android than iOS. In Android, but not iOS, you\n      //    can touch and move your finger slightly and still trigger\n      //    a \"tap\" event. In iOS, moving will cancel the tap in\n      //    both Fabric and non-Fabric. On Android when you move\n      //    your finger, the hit-detection moves from the Android\n      //    platform to JS, so we need the ShadowTree to have knowledge\n      //    of the current position.\n      this._animatedValueListener = ({value}) => {\n        // When the AnimatedInterpolation is recreated, it always initializes\n        // to a value of zero and emits a value change of 0 to its listeners.\n        if (value === 0 && !this._haveReceivedInitialZeroTranslateY) {\n          this._haveReceivedInitialZeroTranslateY = true;\n          return;\n        }\n        if (this._timer) {\n          clearTimeout(this._timer);\n        }\n        this._timer = setTimeout(() => {\n          if (value !== this.state.translateY) {\n            this.setState({\n              translateY: value,\n            });\n          }\n        }, this._debounceTimeout);\n      };\n    }\n    if (this.state.translateY !== 0 && this.state.translateY != null) {\n      this._haveReceivedInitialZeroTranslateY = false;\n    }\n    this._animatedValueListenerId = translateY.addListener(\n      this._animatedValueListener,\n    );\n  }\n\n  _onLayout = (event: any) => {\n    const layoutY = event.nativeEvent.layout.y;\n    const layoutHeight = event.nativeEvent.layout.height;\n    const measured = true;\n\n    if (\n      layoutY !== this.state.layoutY ||\n      layoutHeight !== this.state.layoutHeight ||\n      measured !== this.state.measured\n    ) {\n      this._shouldRecreateTranslateY = true;\n    }\n\n    this.setState({\n      measured,\n      layoutY,\n      layoutHeight,\n    });\n\n    this.props.onLayout(event);\n    const child = React.Children.only(this.props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  _setComponentRef = ref => {\n    this._ref = ref;\n  };\n\n  render(): React.Node {\n    // Fabric Detection\n    const isFabric = !!(\n      // An internal transform mangles variables with leading \"_\" as private.\n      // eslint-disable-next-line dot-notation\n      (this._ref && this._ref['_internalInstanceHandle']?.stateNode?.canonical)\n    );\n    // Initially and in the case of updated props or layout, we\n    // recreate this interpolated value. Otherwise, we do not recreate\n    // when there are state changes.\n    if (this._shouldRecreateTranslateY) {\n      const {inverted, scrollViewHeight} = this.props;\n      const {measured, layoutHeight, layoutY, nextHeaderLayoutY} = this.state;\n      const inputRange: Array<number> = [-1, 0];\n      const outputRange: Array<number> = [0, 0];\n\n      if (measured) {\n        if (inverted) {\n          // The interpolation looks like:\n          // - Negative scroll: no translation\n          // - `stickStartPoint` is the point at which the header will start sticking.\n          //   It is calculated using the ScrollView viewport height so it is a the bottom.\n          // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n          //   will be negative.\n          // - From 0 to `stickStartPoint` no translation. This will cause the header\n          //   to scroll normally until it reaches the top of the scroll view.\n          // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n          //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n          // - Past the collision with the next header y: no more translation. This will cause the\n          //   header to continue scrolling up and make room for the next sticky header.\n          //   In the case that there is no next header just translate equally to\n          //   scroll indefinitely.\n          if (scrollViewHeight != null) {\n            const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n            if (stickStartPoint > 0) {\n              inputRange.push(stickStartPoint);\n              outputRange.push(0);\n              inputRange.push(stickStartPoint + 1);\n              outputRange.push(1);\n              // If the next sticky header has not loaded yet (probably windowing) or is the last\n              // we can just keep it sticked forever.\n              const collisionPoint =\n                (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n              if (collisionPoint > stickStartPoint) {\n                inputRange.push(collisionPoint, collisionPoint + 1);\n                outputRange.push(\n                  collisionPoint - stickStartPoint,\n                  collisionPoint - stickStartPoint,\n                );\n              }\n            }\n          }\n        } else {\n          // The interpolation looks like:\n          // - Negative scroll: no translation\n          // - From 0 to the y of the header: no translation. This will cause the header\n          //   to scroll normally until it reaches the top of the scroll view.\n          // - From header y to when the next header y hits the bottom edge of the header: translate\n          //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n          // - Past the collision with the next header y: no more translation. This will cause the\n          //   header to continue scrolling up and make room for the next sticky header.\n          //   In the case that there is no next header just translate equally to\n          //   scroll indefinitely.\n          inputRange.push(layoutY);\n          outputRange.push(0);\n          // If the next sticky header has not loaded yet (probably windowing) or is the last\n          // we can just keep it sticked forever.\n          const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n          if (collisionPoint >= layoutY) {\n            inputRange.push(collisionPoint, collisionPoint + 1);\n            outputRange.push(\n              collisionPoint - layoutY,\n              collisionPoint - layoutY,\n            );\n          } else {\n            inputRange.push(layoutY + 1);\n            outputRange.push(1);\n          }\n        }\n      }\n\n      this.updateTranslateListener(\n        this.props.scrollAnimatedValue.interpolate({\n          inputRange,\n          outputRange,\n        }),\n        isFabric,\n        this.props.hiddenOnScroll\n          ? new AnimatedDiffClamp(\n              this.props.scrollAnimatedValue\n                .interpolate({\n                  extrapolateLeft: 'clamp',\n                  inputRange: [layoutY, layoutY + 1],\n                  outputRange: ([0, 1]: Array<number>),\n                })\n                .interpolate({\n                  inputRange: [0, 1],\n                  outputRange: ([0, -1]: Array<number>),\n                }),\n              -this.state.layoutHeight,\n              0,\n            )\n          : null,\n      );\n    }\n\n    const child = React.Children.only(this.props.children);\n\n    // TODO T68319535: remove this if NativeAnimated is rewritten for Fabric\n    const passthroughAnimatedPropExplicitValues =\n      isFabric && this.state.translateY != null\n        ? {\n            style: {transform: [{translateY: this.state.translateY}]},\n          }\n        : null;\n\n    return (\n      <AnimatedView\n        collapsable={false}\n        nativeID={this.props.nativeID}\n        onLayout={this._onLayout}\n        ref={this._setComponentRef}\n        style={[\n          child.props.style,\n          styles.header,\n          {transform: [{translateY: this._translateY}]},\n        ]}\n        passthroughAnimatedPropExplicitValues={\n          passthroughAnimatedPropExplicitValues\n        }>\n        {React.cloneElement(child, {\n          style: styles.fill, // We transfer the child style to the wrapper.\n          onLayout: undefined, // we call this manually through our this._onLayout\n        })}\n      </AnimatedView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n    position: 'relative',\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nmodule.exports = ScrollViewStickyHeader;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}